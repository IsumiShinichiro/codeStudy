public static String getParameterFromURL(String url, String key) {
    String value = null;
    
    // 判断 URL 是否包含参数
    if (url.contains("?")) {
        String parameters = url.substring(url.indexOf("?") + 1);
        
        // 将参数按 & 分割成数组
        String[] paramArray = parameters.split("&");
        
        // 遍历参数数组
        for (String param : paramArray) {
            String[] keyValue = param.split("=");
            
            // 判断参数的键是否与指定的键相等
            if (keyValue.length == 2 && keyValue[0].equals(key)) {
                value = keyValue[1];
                break;
            }
        }
    }
    
    return value;
}
SELECT 
    group_id,
    SUM(total) AS total_sum,
    SUM(success) AS success_sum,
    ROUND(SUM(success) / SUM(total) * 100, 2) AS success_rate
FROM 
    data_table
GROUP BY 
    group_id;
好的,我明白了。你想要以指定的日期范围(2024-05-20到2024-05-28)为基础,生成包含所有日期的数据列表,对于没有数据的日期,将对应的数据设置为null。

以下是修改后的Java代码:

```java
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class DataTransformer {
    public static List<FeatureData> transformData(List<DailyData> dailyDataList, LocalDate startDate, LocalDate endDate) {
        Map<String, FeatureData> featureMap = new HashMap<>();
        List<TotalData> totalDataList = new ArrayList<>();

        // 生成日期列表
        List<String> dateList = generateDateList(startDate, endDate);

        for (String date : dateList) {
            // 初始化总计数据
            TotalData totalData = new TotalData();
            totalData.setDate(date);
            totalDataList.add(totalData);

            // 查找当前日期的数据
            for (DailyData dailyData : dailyDataList) {
                if (dailyData.getDate().equals(date)) {
                    String feature = dailyData.getFeature();
                    int total = dailyData.getTotal();
                    int success = dailyData.getSuccess();
                    double passRate = dailyData.getPassRate();

                    // 更新特性数据
                    FeatureData featureData = featureMap.get(feature);
                    if (featureData == null) {
                        featureData = new FeatureData();
                        featureData.setFeature(feature);
                        featureData.setChild(new ArrayList<>());
                        featureMap.put(feature, featureData);
                    }
                    featureData.getChild().add(dailyData);

                    // 更新总计数据
                    totalData.setTotal(totalData.getTotal() + total);
                    totalData.setSuccess(totalData.getSuccess() + success);
                }
            }

            // 计算总计的通过率
            if (totalData.getTotal() > 0) {
                totalData.setPassRate((double) totalData.getSuccess() / totalData.getTotal());
            }
        }

        // 将特性数据转换为列表,并填充空缺的日期
        List<FeatureData> featureDataList = new ArrayList<>();
        for (FeatureData featureData : featureMap.values()) {
            fillMissingDates(featureData.getChild(), dateList);
            featureDataList.add(featureData);
        }

        // 将总计数据作为最后一个特性添加到列表中
        FeatureData totalFeatureData = new FeatureData();
        totalFeatureData.setFeature("总计");
        totalFeatureData.setChild(new ArrayList<>(totalDataList));
        featureDataList.add(totalFeatureData);

        return featureDataList;
    }

    private static List<String> generateDateList(LocalDate startDate, LocalDate endDate) {
        List<String> dateList = new ArrayList<>();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        while (!startDate.isAfter(endDate)) {
            dateList.add(startDate.format(formatter));
            startDate = startDate.plusDays(1);
        }
        return dateList;
    }

    private static void fillMissingDates(List<DailyData> dailyDataList, List<String> dateList) {
        Map<String, DailyData> dailyDataMap = new HashMap<>();
        for (DailyData dailyData : dailyDataList) {
            dailyDataMap.put(dailyData.getDate(), dailyData);
        }

        dailyDataList.clear();
        for (String date : dateList) {
            DailyData dailyData = dailyDataMap.get(date);
            if (dailyData == null) {
                dailyData = new DailyData();
                dailyData.setDate(date);
            }
            dailyDataList.add(dailyData);
        }
    }
}
```

这段代码的主要改动如下:

1. 新增了 `generateDateList` 方法,用于生成指定日期范围内的所有日期列表。

2. 在 `transformData` 方法中,先生成日期列表,然后遍历日期列表,对于每个日期:
   - 初始化总计数据 `TotalData` 对象。
   - 查找当前日期的数据,如果存在则更新特性数据和总计数据。
   - 计算总计的通过率。

3. 新增了 `fillMissingDates` 方法,用于填充特性数据中空缺的日期。
   - 将特性数据列表转换为以日期为键的Map。
   - 遍历日期列表,对于每个日期,从Map中获取对应的数据,如果不存在则创建一个新的 `DailyData` 对象。
   - 将填充后的数据列表重新赋值给特性数据的 `child` 列表。

4. 在将特性数据转换为列表时,调用 `fillMissingDates` 方法填充空缺的日期。

调用 `transformData` 方法时,需要传入原始数据列表以及起始日期和结束日期:

```java
List<DailyData> dailyDataList = // 从数据库或其他来源获取原始数据
LocalDate startDate = LocalDate.of(2024, 5, 20);
LocalDate endDate = LocalDate.of(2024, 5, 28);
List<FeatureData> featureDataList = DataTransformer.transformData(dailyDataList, startDate, endDate);好的,我明白了。你想使用同一个实体类 `DailyData` 来存储原始数据和转换后的数据,以简化代码。

以下是使用同一个实体类的修改后的Java代码:

```java
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class DataTransformer {
    public static List<DailyData> transformData(List<DailyData> dailyDataList, LocalDate startDate, LocalDate endDate) {
        Map<String, List<DailyData>> featureMap = new HashMap<>();
        List<DailyData> totalDataList = new ArrayList<>();

        // 生成日期列表
        List<String> dateList = generateDateList(startDate, endDate);

        for (String date : dateList) {
            // 初始化总计数据
            DailyData totalData = new DailyData();
            totalData.setFeature("总计");
            totalData.setDate(date);
            totalDataList.add(totalData);

            // 查找当前日期的数据
            for (DailyData dailyData : dailyDataList) {
                if (dailyData.getDate().equals(date)) {
                    String feature = dailyData.getFeature();
                    int total = dailyData.getTotal();
                    int success = dailyData.getSuccess();
                    double passRate = dailyData.getPassRate();

                    // 更新特性数据
                    List<DailyData> featureDataList = featureMap.get(feature);
                    if (featureDataList == null) {
                        featureDataList = new ArrayList<>();
                        featureMap.put(feature, featureDataList);
                    }
                    featureDataList.add(dailyData);

                    // 更新总计数据
                    totalData.setTotal(totalData.getTotal() + total);
                    totalData.setSuccess(totalData.getSuccess() + success);
                }
            }

            // 计算总计的通过率
            if (totalData.getTotal() > 0) {
                totalData.setPassRate((double) totalData.getSuccess() / totalData.getTotal());
            }
        }

        // 将特性数据转换为列表,并填充空缺的日期
        List<DailyData> transformedDataList = new ArrayList<>();
        for (List<DailyData> featureDataList : featureMap.values()) {
            fillMissingDates(featureDataList, dateList);
            transformedDataList.addAll(featureDataList);
        }

        // 将总计数据添加到列表中
        transformedDataList.addAll(totalDataList);

        return transformedDataList;
    }

    private static List<String> generateDateList(LocalDate startDate, LocalDate endDate) {
        List<String> dateList = new ArrayList<>();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        while (!startDate.isAfter(endDate)) {
            dateList.add(startDate.format(formatter));
            startDate = startDate.plusDays(1);
        }
        return dateList;
    }

    private static void fillMissingDates(List<DailyData> dailyDataList, List<String> dateList) {
        Map<String, DailyData> dailyDataMap = new HashMap<>();
        for (DailyData dailyData : dailyDataList) {
            dailyDataMap.put(dailyData.getDate(), dailyData);
        }

        dailyDataList.clear();
        for (String date : dateList) {
            DailyData dailyData = dailyDataMap.get(date);
            if (dailyData == null) {
                dailyData = new DailyData();
                dailyData.setDate(date);
            }
            dailyDataList.add(dailyData);
        }
    }
}
```

这段代码的主要改动如下:

1. 将 `featureMap` 的值类型更改为 `List<DailyData>`,用于存储每个特性的数据列表。

2. 在 `transformData` 方法中,对于每个日期:
   - 初始化总计数据 `DailyData` 对象,并将特性设置为"总计"。
   - 查找当前日期的数据,如果存在则更新特性数据列表和总计数据。
   - 计算总计的通过率。

3. 将特性数据列表和总计数据列表合并到一个新的列表 `transformedDataList` 中。

4. `generateDateList` 和 `fillMissingDates` 方法保持不变。

调用 `transformData` 方法的方式与之前相同:

```java
List<DailyData> dailyDataList = // 从数据库或其他来源获取原始数据
LocalDate startDate = LocalDate.of(2024, 5, 20);
LocalDate endDate = LocalDate.of(2024, 5, 28);
List<DailyData> transformedDataList = DataTransformer.transformData(dailyDataList, startDate, endDate);
```

这将根据指定的日期范围生成包含所有日期的数据列表,对于没有数据的日期,将对应的数据设置为默认值。最后返回转换后的数据列表 `transformedDataList`,其中包含了按特性分组的数据以及总计数据。

希望这个使用同一个实体类的修改后的解决方案能够满足你的需求,并简化了代码。如果你还有任何问题或需要进一步的帮助,欢迎随时问我。
```

这将根据指定的日期范围生成包含所有日期的数据列表,对于没有数据的日期,将对应的数据设置为null。最后返回以特性为主的数据列表 `featureDataList`,其中最后一个元素为总计数据。

希望这个修改后的解决方案能够满足你的需求。如果你还有任何问题或需要进一步的帮助,欢迎随时问我。
